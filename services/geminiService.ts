// FIX: Removed `VideosOperation` from the import as it is not an exported member of '@google/genai'.
import { GoogleGenAI, Modality } from "@google/genai";
import { AIModel, ModelConfig } from '../types';

if (!process.env.API_KEY) {
  throw new Error("API_KEY environment variable is not set.");
}

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

export const generateContent = async (prompt: string, modelPersonality: AIModel, modelConfig?: ModelConfig): Promise<string> => {
  try {
    const config: any = {
      systemInstruction: modelPersonality.systemInstruction,
    };

    if (modelConfig) {
        config.temperature = modelConfig.temperature;
        config.topP = modelConfig.topP;
        config.topK = modelConfig.topK;
        
        if (modelConfig.maxOutputTokens > 0) {
            config.maxOutputTokens = modelConfig.maxOutputTokens;
            // Per guidelines, set thinkingBudget if maxOutputTokens is set for flash model
            config.thinkingConfig = { thinkingBudget: Math.floor(modelConfig.maxOutputTokens / 4) };
        }
    }

    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: prompt,
      config,
    });
    return response.text;
  } catch (error) {
    console.error("Error generating content:", error);
    if (error instanceof Error) {
        return `Error from API: ${error.message}`;
    }
    return "An unknown error occurred while generating content.";
  }
};

export const generateImage = async (prompt: string): Promise<string> => {
  try {
    const response = await ai.models.generateImages({
      model: 'imagen-4.0-generate-001',
      prompt: prompt,
      config: {
        numberOfImages: 1,
        outputMimeType: 'image/png',
        aspectRatio: '1:1',
      },
    });

    if (response.generatedImages && response.generatedImages.length > 0) {
      return response.generatedImages[0].image.imageBytes;
    } else {
      throw new Error("No image was generated by the API.");
    }
  } catch (error) {
    console.error("Error generating image:", error);
    if (error instanceof Error) {
        throw error;
    }
    throw new Error("An unknown error occurred while generating the image.");
  }
};

export const editImage = async (prompt: string, imageBase64: string, mimeType: string): Promise<string> => {
  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash-image',
      contents: {
        parts: [
          {
            inlineData: {
              data: imageBase64,
              mimeType: mimeType,
            },
          },
          {
            text: prompt,
          },
        ],
      },
      config: {
        responseModalities: [Modality.IMAGE, Modality.TEXT],
      },
    });

    const candidate = response?.candidates?.[0];

    if (candidate?.content?.parts) {
      for (const part of candidate.content.parts) {
        if (part.inlineData) {
          return part.inlineData.data;
        }
      }
    }

    if (response?.promptFeedback?.blockReason) {
      throw new Error(`Request was blocked. Reason: ${response.promptFeedback.blockReason}`);
    }
    
    if (candidate?.finishReason && candidate.finishReason !== 'STOP') {
      throw new Error(`Image generation stopped for reason: ${candidate.finishReason}`);
    }

    throw new Error("No image was returned by the API. The response may have been blocked or empty.");
  } catch (error) {
    console.error("Error editing image:", error);
    if (error instanceof Error) {
        throw error;
    }
    throw new Error("An unknown error occurred while editing the image.");
  }
};

export const generateVideo = async (
  prompt: string, 
  image: { data: string; mimeType: string } | undefined,
  onProgress: (message: string) => void
): Promise<string> => {
  try {
    onProgress("Starting video generation...");
    
    const requestPayload: any = {
      model: 'veo-2.0-generate-001',
      prompt: prompt,
      config: {
        numberOfVideos: 1
      }
    };

    if (image) {
      requestPayload.image = {
        imageBytes: image.data,
        mimeType: image.mimeType,
      };
    }

    // FIX: Removed explicit `VideosOperation` type and allowed type inference, as the type is not exported from the package.
    let operation = await ai.models.generateVideos(requestPayload);
    
    onProgress("Processing request... This may take a few minutes.");

    while (!operation.done) {
      await new Promise(resolve => setTimeout(resolve, 10000)); // Poll every 10 seconds
      onProgress("Still working on it... Great things take time!");
      operation = await ai.operations.getVideosOperation({ operation: operation });
    }

    if (operation.response?.generatedVideos?.[0]?.video?.uri) {
        onProgress("Video generated successfully! Fetching data...");
        const downloadLink = operation.response.generatedVideos[0].video.uri;
        const response = await fetch(`${downloadLink}&key=${process.env.API_KEY}`);
        if (!response.ok) {
            throw new Error(`Failed to fetch video data: ${response.statusText}`);
        }
        const videoBlob = await response.blob();
        
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result as string);
            reader.onerror = reject;
            reader.readAsDataURL(videoBlob);
        });

    } else {
        const errorDetails = operation.error ? `${operation.error.code}: ${operation.error.message}` : "No video URI found in response.";
        throw new Error(`Video generation failed. ${errorDetails}`);
    }
  } catch (error) {
    console.error("Error generating video:", error);
    if (error instanceof Error) {
        throw error;
    }
    throw new Error("An unknown error occurred while generating the video.");
  }
};